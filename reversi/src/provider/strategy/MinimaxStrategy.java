package provider.strategy;

import java.util.Objects;
import java.util.Optional;

import provider.model.HexState;
import provider.model.HexagonalReversi;
import provider.model.HexPosn;
import provider.model.ReadOnlyHexagonalReversi;

/**
 * Represents a strategy that values moves based on how little value they provide
 * for the opponent based on the opponent's strategy.
 */
public class MinimaxStrategy extends AbstractStrategy implements Strategy {

  /**
   * Represents the opponent's strategy.
   */
  private final AbstractStrategy opponentStrategy;


  /**
   * Default constructor for a Minimax strategy. Assumes opponent uses Greedy.
   */
  public MinimaxStrategy() {
    this.opponentStrategy = new GreedyStrategy();
  }

  /**
   * Constructor for a Minimax strategy.
   *
   * @param opponentStrategy The opponent's strategy
   */
  public MinimaxStrategy(AbstractStrategy opponentStrategy) {
    this.opponentStrategy = Objects.requireNonNull(opponentStrategy);
  }

  /**
   * The move value is just 1 minus the value generated by the best move that the opponent
   * can make in the position after the current move.
   *
   * @param model The model
   * @param color The player to play
   * @param move The move
   * @return The absolute value generated by the move
   */
  @Override
  public double getMoveValue(ReadOnlyHexagonalReversi model, HexState color, HexPosn move) {
    HexagonalReversi experimentationModel = model.deepCopy();
    experimentationModel.placePiece(move.q, move.r, move.s, color);

    HexState opponent = color == HexState.WHITE ? HexState.BLACK : HexState.WHITE;

    Optional<HexPosn> opponentBestMove =
            this.opponentStrategy.bestMove(experimentationModel, opponent);

    return opponentBestMove.map(posn3D ->
                    1 - this.opponentStrategy.getMoveValue(
                            experimentationModel,
                            opponent,
                            posn3D
                    )
            ).orElse(0.0);
  }
}