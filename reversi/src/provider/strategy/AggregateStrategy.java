package provider.strategy;

import java.util.List;

import provider.model.HexPosn;
import provider.model.HexState;
import provider.model.ReadOnlyHexagonalReversi;

/**
 * Represents the aggregation of multiple strategies.
 */
public class AggregateStrategy extends AbstractStrategy implements Strategy {

  /**
   * A list of strategies, prioritized by the order in which they are given.
   */
  private final List<AbstractStrategy> strategies;

  /**
   * Constructor for an aggregate strategy.
   *
   * @param strategies The list of strategies, prioritized by the order in which they are given.
   */
  public AggregateStrategy(List<AbstractStrategy> strategies) {
    if (strategies == null) {
      throw new IllegalArgumentException("Null list of strategies");
    }

    this.strategies = strategies;
  }

  /**
   * The value of a move is an aggregation of the values generated by the move in accordance
   * with each of the strategies.
   *
   * @param model The model
   * @param color The player to play
   * @param move The move to be made
   * @return The absolute value generated by the move.
   */
  @Override
  double getMoveValue(ReadOnlyHexagonalReversi model, HexState color, HexPosn move) {
    double totalMoveValue = 0;
    int numberOfStrategies = strategies.size();

    //To get around the possibility of nesting strategies to make them matter less than
    //the minimum barrier, 1/totalNumberOfHexes
    if (numberOfStrategies == 1) {
      return strategies.get(0).getMoveValue(model, color, move);
    }

    int layers = model.getNumLayers();

    double totalNumberOfHexes = 1 + (6.0 * (layers * (layers - 1))) / 2;

    //To ensure that a score that is prioritized less than another score does not somehow yield
    //more value than it in the final equation, separate each by a factor of the total number of
    //hexes. The minimum Greedy score is 1/totalNumberOfHexes, so if one has the minimum, it will
    //contribute the same amount as the next strategy at max.
    for (int i = 0; i < numberOfStrategies; i++) {
      totalMoveValue +=
              strategies.get(i).getMoveValue(model, color, move) *
                      Math.pow(totalNumberOfHexes, numberOfStrategies - i - 1);
    }

    //To keep the value between 0 and 1, in case someone uses an aggregate of aggregates
    return totalMoveValue / Math.pow(totalNumberOfHexes, numberOfStrategies);
  }
}
