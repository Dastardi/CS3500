DESIGN & IMPLEMENTATION CRITIQUE AND SUGGESTIONS
Some of their interfaces didn’t seem super straightforward/flexible to us, particularly the slightly convoluted PlayerActionListener logic which overlaps with CanvasActionListener. This made setting up the listener system difficult. Their panel has both a CanvasActionListener and a list of PlayerActionListeners which are added to each tile individually. The code was slightly complicated to understand because it listens in every single tile even though the tiles have little to no communication with anything else other than being told to draw themselves.
Some of the methods in their interfaces felt unnecessary (such as isVisible in HexReversiGUI), which is not ideal.
It felt like the Player interface was trying to do a lot on its own, but most of it could have been handled directly in the controller. It still works, but we designed our code to have extremely simple players and do nearly all functionality in the controller.
Their strategy design and implementation was very clean and easy to use, so props for that! We like the structure of getting move values and how smoothly the players and strategies work together.
While complicated, their view system is undeniably capable, with a solid resizing system and all components necessary to play a full game. Two small critiques of their view that we want to suggest are the lack of messages sent to the players (which may have been an issue on our end, which is why we’re not making a big deal of it - but if that is how it was designed, we want to emphasize that message dialogues make it a lot more fun!) and the fact that the board didn’t fit perfectly into the frame. Neither are disastrous by any means, but more messages about the game state and a cleaner visual might make the game feel smoother. We think trying to figure out a way to iron out the CanvasEvent and PlayerActionListeners and reducing the amount of work their Player and HexTile classes take on would make their code simpler and more flexible.

DOCUMENTATION CRITIQUE
We would have loved more documentation and commenting throughout the code, as explanations of how specific methods work or how they’re related to other methods is really helpful when trying to understand someone else’s code. Commenting can also be helpful when code uses ‘magic numbers’ to do math. For example, we found the  apparently random figure 1.7321 in constructing the board… what does 1.7321 represent? It’s obviously something important, but an explanation there along with a few other magic numbers would make the code a lot easier to understand.
Also, some of the existing documentation could have been more specific. For example, the Javadoc for the getNumLayers() method simply says “gets the number of layers” without explaining what a layer is, and this caused problems for a while because we misinterpreted the definition of “layer” before asking for clarification.
Overall, they did have generally solid Javadocs and we were able to get a sense for the code after spending some time with it, but understanding their codebase would have been faster with a bit more explanation in both Javadocs and comments.

LIMITATIONS/CHANGES & OUR EXPERIENCE ADAPTING
Because of how differently our programs worked, implementing their code wasn’t trivial. We ended up making a number of our classes implement new interfaces to allow them to be passed around and used by both views. We adapted their strategies into our Player interface, as using their Player would have necessitated a fair few changes to our controller. Some of our problems arose in testing, as it takes a while to iterate over triple nested for-loops with thousands of values, so we had to get creative with how we analyzed problems in adaptation.
They seem to check their coordinates differently in their model. Therefore, when they build their board in their panel, they pass in coordinates using a cubic coordinate system. We use an axial system for our board and our indexing is extremely different, so we were getting a lot of exceptions in our model. We requested that they either make their error checking more robust or add a try/catch in the constructor of their HexReversiPanel. They added a general try/catch in the nested for-loop in HexReversiPanel on line 63, which solved our issues and allowed us to finish it off.
Their controller listens to their panel, while our controller listens to our view which listens to our panel. It was difficult to reconcile these two because our controller doesn’t have an easy way to access the panel, so we did something a little odd in our code to make it work.
For the most part, however, it seems like both their group and our group thought about this project in similar ways, and the structure of each of our codebases is similar enough that we were able to find solutions to all of our challenges and reconcile all the differences in the code.